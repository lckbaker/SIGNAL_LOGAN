for (j in 1:numChannels){
newCols <- paste0("nb", i, ".", colNames[j])
colNames <- c(colNames, newCols)
}
colNames <- c(colNames,paste0("nb", i, ".dist"))
}
colNames
# Add back additional columns to be included
colNames2 <- c(colNames, "numNeighbors", colnames(df[,c(2,3,7)]) )
length(colNames2)
names(df2) <- colNames2
cat(colnames(df2))
head(df2)
# Function to calculate distance
calDist <- function(x, y, X, Y){
dis <- sqrt((x-X)^2 + (y-Y)^2)
return(dis)
}
# Identify the neighboring cells within the distance 'd'
for (index in 1:nrow(df)){
X <- df[index, 'x']
Y <- df[index, 'y']
# Print out the progress status
message(paste0(index, "/", ncol(df), "\n"))
# find all neighboring cells within the DISTANCE
neighbors <- df[sqrt((df$x-X)^2 + (df$y-Y)^2) <= d & sqrt((df$x-X)^2 + (df$y-Y)^2) > 0,]
if(nrow(neighbors) > 0){
# Find distance between the target cell and its neighbors
neighbors$distance <- mapply(calDist, neighbors$x, neighbors$y, X, Y)
# Rank the neighboring cells based on distance
neighbors_ranked <- neighbors[order(neighbors$distance),]
# Add the number of neighboring cells to the dataframe
numNeighbors <- dim(neighbors)[1]
df2[index, "numNeighbors"] <- numNeighbors
# Add the closest 6 neighboring cells into the dataframe
if(nrow(neighbors_ranked) >= 6){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,8:12]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,8:12]
df2[index, 35]      <- neighbors_ranked[5,'distance']
df2[index,c(36:40)] <- neighbors_ranked[6,8:12]
df2[index, 41]      <- neighbors_ranked[6,'distance']
}
else if(nrow(neighbors_ranked) == 5){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,8:12]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,8:12]
df2[index, 35]      <- neighbors_ranked[5,'distance']
}
else if(nrow(neighbors_ranked) == 4){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,8:12]
df2[index, 29]      <- neighbors_ranked[4,'distance']
}
else if(nrow(neighbors_ranked) == 3){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
}
else if(nrow(neighbors_ranked) == 2){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
}
else if(nrow(neighbors_ranked) == 1){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
}
}
else{
# ignore if no neighbor found
# because the df2 has already pre-populated
}
}
return(df2)
}
# Find the neighboring cells and return new dataframe with original channels and medians of the desired channels
myData2 <- findNeighbors(myData, 12)
library("robustbase")
# Find all neighboring cells within a radius
findNeighbors <- function(myData, distance){
df <- myData
d <- distance
numNeighbors <- 0 # vector to store number of neighbors for each cell
# Add empty columns (numCol = numChannel*6 + 1) for nearest 6 cells and 5 channel data to the dataframe
# to store the average channel data and 'numNeighbors'
# number of CHANNEL data columns to be used (e.g., 5 => B220, CD3, CD4, CD8, CD31)
numChannels <- 5
# Create a new dataframe with the channel information, top 6 neighbors information(6), plus_distance, numNeighbors(1)
# and X(2), Y(3) coordinates, ID(7) columns
df2 <- cbind(df[,9:13], matrix(data=0, nrow = nrow(df), ncol = ((numChannels + 1)*6 +1)), df[,c(2,3,7)])
dim(df2)
# Add channel names to all columns containing neighbor cell info
colNames <- colnames(df[,9:13])
for (i in 1:6){ # 6 neighbors
for (j in 1:numChannels){
newCols <- paste0("nb", i, ".", colNames[j])
colNames <- c(colNames, newCols)
}
colNames <- c(colNames,paste0("nb", i, ".dist"))
}
colNames
# Add back additional columns to be included
colNames2 <- c(colNames, "numNeighbors", colnames(df[,c(2,3,7)]) )
length(colNames2)
names(df2) <- colNames2
cat(colnames(df2))
head(df2)
# Function to calculate distance
calDist <- function(x, y, X, Y){
dis <- sqrt((x-X)^2 + (y-Y)^2)
return(dis)
}
# Identify the neighboring cells within the distance 'd'
for (index in 1:nrow(df)){
X <- df[index, 'x']
Y <- df[index, 'y']
# Print out the progress status
message(paste0(index, "/", nrow(df), "\n"))
# find all neighboring cells within the DISTANCE
neighbors <- df[sqrt((df$x-X)^2 + (df$y-Y)^2) <= d & sqrt((df$x-X)^2 + (df$y-Y)^2) > 0,]
if(nrow(neighbors) > 0){
# Find distance between the target cell and its neighbors
neighbors$distance <- mapply(calDist, neighbors$x, neighbors$y, X, Y)
# Rank the neighboring cells based on distance
neighbors_ranked <- neighbors[order(neighbors$distance),]
# Add the number of neighboring cells to the dataframe
numNeighbors <- dim(neighbors)[1]
df2[index, "numNeighbors"] <- numNeighbors
# Add the closest 6 neighboring cells into the dataframe
if(nrow(neighbors_ranked) >= 6){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,8:12]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,8:12]
df2[index, 35]      <- neighbors_ranked[5,'distance']
df2[index,c(36:40)] <- neighbors_ranked[6,8:12]
df2[index, 41]      <- neighbors_ranked[6,'distance']
}
else if(nrow(neighbors_ranked) == 5){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,8:12]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,8:12]
df2[index, 35]      <- neighbors_ranked[5,'distance']
}
else if(nrow(neighbors_ranked) == 4){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,8:12]
df2[index, 29]      <- neighbors_ranked[4,'distance']
}
else if(nrow(neighbors_ranked) == 3){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,8:12]
df2[index, 23]      <- neighbors_ranked[3,'distance']
}
else if(nrow(neighbors_ranked) == 2){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,8:12]
df2[index, 17]      <- neighbors_ranked[2,'distance']
}
else if(nrow(neighbors_ranked) == 1){
df2[index, c(6:10)] <- neighbors_ranked[1,8:12]
df2[index, 11]      <- neighbors_ranked[1,'distance']
}
}
else{
# ignore if no neighbor found
# because the df2 has already pre-populated
}
}
return(df2)
}
# Find the neighboring cells and return new dataframe with original channels and medians of the desired channels
myData2 <- findNeighbors(myData, 12)
# Save the data to a file
write.csv(myData2, file="Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist.csv", sep = ",",  row.names = FALSE, col.names = TRUE, quote = FALSE)
library(Rtsne)
set.seed(42)
# Generate neighbor cell count distribution histograms
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_distribution.jpeg"), width=1200, height=1200)
hist(myData2[,"numNeighbors"], col="blue", cex.lab=3, cex.axis=3, cex.main=3, cex.sub=3)
dev.off()
library(Rtsne)
set.seed(42)
# Generate neighbor cell count distribution histograms
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_distribution.jpeg"), width=1200, height=1200)
hist(myData2[,"numNeighbors"], col="blue", cex.lab=3, cex.axis=3, cex.main=3, cex.sub=3)
dev.off()
## Generating tSNE plots with Top6 neighbors information
for(i in c(10,30,50,80,100))
{
# run tSNE analysis
rtsne_out2 <- Rtsne(as.matrix(myData2[,1:41]), check_duplicates = FALSE, perplexity = i)
#Create tSNE plot
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i,".jpeg"), width=1200, height=1200)
plot(rtsne_out2$Y, main=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i), xlab='tSNE dimension 1', ylab='tSNE dimension 2', type = "p", cex=2, col = "blue")
dev.off()
# Save tSNE plot coordiates
tSNE_plot_coords2 <- rtsne_out2$Y
rownames(tSNE_plot_coords2) <- rownames(myData2)
colnames(tSNE_plot_coords2) <- c("tSNE dimension 1", "tSNE dimension 2")
head(tSNE_plot_coords2)
write.csv(tSNE_plot_coords2, file=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i, "_coords.csv"), row.names = FALSE, col.names = TRUE)
}
myData <- read.csv(file="./Domains_Ms1LN1_stat_tissue1.csv", header = TRUE, sep = ",")
# Change the column names for X Y coorindates
colnames(myData)[which(names(myData) == "Position.X")] <- "x"
colnames(myData)[which(names(myData) == "Position.Y")] <- "y"
dim(myData)
head(myData)
library("robustbase")
# Find all neighboring cells within a radius
findNeighbors <- function(myData, distance){
df <- myData
d <- distance
numNeighbors <- 0 # vector to store number of neighbors for each cell
# Add empty columns (numCol = numChannel*6 + 1) for nearest 6 cells and 5 channel data to the dataframe
# to store the average channel data and 'numNeighbors'
# number of CHANNEL data columns to be used (e.g., 5 => B220, CD3, CD4, CD8, CD31)
numChannels <- 5
# Create a new dataframe with the channel information, top 6 neighbors information(6), plus_distance, numNeighbors(1)
# and X(2), Y(3) coordinates, ID(7) columns
df2 <- cbind(df[,9:13], matrix(data=0, nrow = nrow(df), ncol = ((numChannels + 1)*6 +1)), df[,c(2,3,7)])
dim(df2)
# Add channel names to all columns containing neighbor cell info
colNames <- colnames(df[,9:13])
for (i in 1:6){ # 6 neighbors
for (j in 1:numChannels){
newCols <- paste0("nb", i, ".", colNames[j])
colNames <- c(colNames, newCols)
}
colNames <- c(colNames,paste0("nb", i, ".dist"))
}
colNames
# Add back additional columns to be included
colNames2 <- c(colNames, "numNeighbors", colnames(df[,c(2,3,7)]) )
length(colNames2)
names(df2) <- colNames2
cat(colnames(df2))
head(df2)
# Function to calculate distance
calDist <- function(x, y, X, Y){
dis <- sqrt((x-X)^2 + (y-Y)^2)
return(dis)
}
# Identify the neighboring cells within the distance 'd'
for (index in 1:10){
X <- df[index, 'x']
Y <- df[index, 'y']
# Print out the progress status
message(paste0(index, "/", nrow(df), "\n"))
# find all neighboring cells within the DISTANCE
neighbors <- df[sqrt((df$x-X)^2 + (df$y-Y)^2) <= d & sqrt((df$x-X)^2 + (df$y-Y)^2) > 0,]
if(nrow(neighbors) > 0){
# Find distance between the target cell and its neighbors
neighbors$distance <- mapply(calDist, neighbors$x, neighbors$y, X, Y)
# Rank the neighboring cells based on distance
neighbors_ranked <- neighbors[order(neighbors$distance),]
# Add the number of neighboring cells to the dataframe
numNeighbors <- dim(neighbors)[1]
df2[index, "numNeighbors"] <- numNeighbors
# Add the closest 6 neighboring cells into the dataframe
if(nrow(neighbors_ranked) >= 6){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
df2[index,c(36:40)] <- neighbors_ranked[6,9:13]
df2[index, 41]      <- neighbors_ranked[6,'distance']
}
else if(nrow(neighbors_ranked) == 5){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
}
else if(nrow(neighbors_ranked) == 4){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
}
else if(nrow(neighbors_ranked) == 3){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
}
else if(nrow(neighbors_ranked) == 2){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
}
else if(nrow(neighbors_ranked) == 1){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
}
}
else{
# ignore if no neighbor found
# because the df2 has already pre-populated
}
}
return(df2)
}
# Find the neighboring cells and return new dataframe with original channels and medians of the desired channels
myData2 <- findNeighbors(myData, 12)
# Save the data to a file
write.csv(myData2, file="Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist.csv", sep = ",",  row.names = FALSE, col.names = TRUE, quote = FALSE)
library("robustbase")
# Find all neighboring cells within a radius
findNeighbors <- function(myData, distance){
df <- myData
d <- distance
numNeighbors <- 0 # vector to store number of neighbors for each cell
# Add empty columns (numCol = numChannel*6 + 1) for nearest 6 cells and 5 channel data to the dataframe
# to store the average channel data and 'numNeighbors'
# number of CHANNEL data columns to be used (e.g., 5 => B220, CD3, CD4, CD8, CD31)
numChannels <- 5
# Create a new dataframe with the channel information, top 6 neighbors information(6), plus_distance, numNeighbors(1)
# and X(2), Y(3) coordinates, ID(7) columns
df2 <- cbind(df[,9:13], matrix(data=0, nrow = nrow(df), ncol = ((numChannels + 1)*6 +1)), df[,c(2,3,7)])
dim(df2)
# Add channel names to all columns containing neighbor cell info
colNames <- colnames(df[,9:13])
for (i in 1:6){ # 6 neighbors
for (j in 1:numChannels){
newCols <- paste0("nb", i, ".", colNames[j])
colNames <- c(colNames, newCols)
}
colNames <- c(colNames,paste0("nb", i, ".dist"))
}
colNames
# Add back additional columns to be included
colNames2 <- c(colNames, "numNeighbors", colnames(df[,c(2,3,7)]) )
length(colNames2)
names(df2) <- colNames2
cat(colnames(df2))
head(df2)
# Function to calculate distance
calDist <- function(x, y, X, Y){
dis <- sqrt((x-X)^2 + (y-Y)^2)
return(dis)
}
# Identify the neighboring cells within the distance 'd'
for (index in 1:nrow(df)){
X <- df[index, 'x']
Y <- df[index, 'y']
# Print out the progress status
message(paste0(index, "/", nrow(df), "\n"))
# find all neighboring cells within the DISTANCE
neighbors <- df[sqrt((df$x-X)^2 + (df$y-Y)^2) <= d & sqrt((df$x-X)^2 + (df$y-Y)^2) > 0,]
if(nrow(neighbors) > 0){
# Find distance between the target cell and its neighbors
neighbors$distance <- mapply(calDist, neighbors$x, neighbors$y, X, Y)
# Rank the neighboring cells based on distance
neighbors_ranked <- neighbors[order(neighbors$distance),]
# Add the number of neighboring cells to the dataframe
numNeighbors <- dim(neighbors)[1]
df2[index, "numNeighbors"] <- numNeighbors
# Add the closest 6 neighboring cells into the dataframe
if(nrow(neighbors_ranked) >= 6){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
df2[index,c(36:40)] <- neighbors_ranked[6,9:13]
df2[index, 41]      <- neighbors_ranked[6,'distance']
}
else if(nrow(neighbors_ranked) == 5){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
}
else if(nrow(neighbors_ranked) == 4){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
}
else if(nrow(neighbors_ranked) == 3){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
}
else if(nrow(neighbors_ranked) == 2){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
}
else if(nrow(neighbors_ranked) == 1){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
}
}
else{
# ignore if no neighbor found
# because the df2 has already pre-populated
}
}
return(df2)
}
# Find the neighboring cells and return new dataframe with original channels and medians of the desired channels
myData2 <- findNeighbors(myData, 12)
# Save the data to a file
write.csv(myData2, file="Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist.csv", sep = ",",  row.names = FALSE, col.names = TRUE, quote = FALSE)
library(Rtsne)
set.seed(42)
# Generate neighbor cell count distribution histograms
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_distribution.jpeg"), width=1200, height=1200)
hist(myData2[,"numNeighbors"], col="blue", cex.lab=3, cex.axis=3, cex.main=3, cex.sub=3)
dev.off()
## Generating tSNE plots with Top6 neighbors information
for(i in c(10,30,50,80,100))
{
# run tSNE analysis
rtsne_out2 <- Rtsne(as.matrix(myData2[,1:41]), check_duplicates = FALSE, perplexity = i)
#Create tSNE plot
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i,".jpeg"), width=1200, height=1200)
plot(rtsne_out2$Y, main=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i), xlab='tSNE dimension 1', ylab='tSNE dimension 2', type = "p", cex=2, col = "blue")
dev.off()
# Save tSNE plot coordiates
tSNE_plot_coords2 <- rtsne_out2$Y
rownames(tSNE_plot_coords2) <- rownames(myData2)
colnames(tSNE_plot_coords2) <- c("tSNE dimension 1", "tSNE dimension 2")
head(tSNE_plot_coords2)
write.csv(tSNE_plot_coords2, file=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i, "_coords.csv"), row.names = FALSE, col.names = TRUE)
}
install.packages('nortest')
install.packages('plotrix')
shiny::runApp('TRIAGE/app')
