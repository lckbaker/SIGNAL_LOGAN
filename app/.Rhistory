{
# run tSNE analysis
rtsne_out2 <- Rtsne(as.matrix(myData2[,1:41]), check_duplicates = FALSE, perplexity = i)
#Create tSNE plot
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i,".jpeg"), width=1200, height=1200)
plot(rtsne_out2$Y, main=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i), xlab='tSNE dimension 1', ylab='tSNE dimension 2', type = "p", cex=2, col = "blue")
dev.off()
# Save tSNE plot coordiates
tSNE_plot_coords2 <- rtsne_out2$Y
rownames(tSNE_plot_coords2) <- rownames(myData2)
colnames(tSNE_plot_coords2) <- c("tSNE dimension 1", "tSNE dimension 2")
head(tSNE_plot_coords2)
write.csv(tSNE_plot_coords2, file=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i, "_coords.csv"), row.names = FALSE, col.names = TRUE)
}
myData <- read.csv(file="./Domains_Ms1LN1_stat_tissue1.csv", header = TRUE, sep = ",")
# Change the column names for X Y coorindates
colnames(myData)[which(names(myData) == "Position.X")] <- "x"
colnames(myData)[which(names(myData) == "Position.Y")] <- "y"
dim(myData)
head(myData)
library("robustbase")
# Find all neighboring cells within a radius
findNeighbors <- function(myData, distance){
df <- myData
d <- distance
numNeighbors <- 0 # vector to store number of neighbors for each cell
# Add empty columns (numCol = numChannel*6 + 1) for nearest 6 cells and 5 channel data to the dataframe
# to store the average channel data and 'numNeighbors'
# number of CHANNEL data columns to be used (e.g., 5 => B220, CD3, CD4, CD8, CD31)
numChannels <- 5
# Create a new dataframe with the channel information, top 6 neighbors information(6), plus_distance, numNeighbors(1)
# and X(2), Y(3) coordinates, ID(7) columns
df2 <- cbind(df[,9:13], matrix(data=0, nrow = nrow(df), ncol = ((numChannels + 1)*6 +1)), df[,c(2,3,7)])
dim(df2)
# Add channel names to all columns containing neighbor cell info
colNames <- colnames(df[,9:13])
for (i in 1:6){ # 6 neighbors
for (j in 1:numChannels){
newCols <- paste0("nb", i, ".", colNames[j])
colNames <- c(colNames, newCols)
}
colNames <- c(colNames,paste0("nb", i, ".dist"))
}
colNames
# Add back additional columns to be included
colNames2 <- c(colNames, "numNeighbors", colnames(df[,c(2,3,7)]) )
length(colNames2)
names(df2) <- colNames2
cat(colnames(df2))
head(df2)
# Function to calculate distance
calDist <- function(x, y, X, Y){
dis <- sqrt((x-X)^2 + (y-Y)^2)
return(dis)
}
# Identify the neighboring cells within the distance 'd'
for (index in 1:10){
X <- df[index, 'x']
Y <- df[index, 'y']
# Print out the progress status
message(paste0(index, "/", nrow(df), "\n"))
# find all neighboring cells within the DISTANCE
neighbors <- df[sqrt((df$x-X)^2 + (df$y-Y)^2) <= d & sqrt((df$x-X)^2 + (df$y-Y)^2) > 0,]
if(nrow(neighbors) > 0){
# Find distance between the target cell and its neighbors
neighbors$distance <- mapply(calDist, neighbors$x, neighbors$y, X, Y)
# Rank the neighboring cells based on distance
neighbors_ranked <- neighbors[order(neighbors$distance),]
# Add the number of neighboring cells to the dataframe
numNeighbors <- dim(neighbors)[1]
df2[index, "numNeighbors"] <- numNeighbors
# Add the closest 6 neighboring cells into the dataframe
if(nrow(neighbors_ranked) >= 6){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
df2[index,c(36:40)] <- neighbors_ranked[6,9:13]
df2[index, 41]      <- neighbors_ranked[6,'distance']
}
else if(nrow(neighbors_ranked) == 5){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
}
else if(nrow(neighbors_ranked) == 4){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
}
else if(nrow(neighbors_ranked) == 3){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
}
else if(nrow(neighbors_ranked) == 2){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
}
else if(nrow(neighbors_ranked) == 1){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
}
}
else{
# ignore if no neighbor found
# because the df2 has already pre-populated
}
}
return(df2)
}
# Find the neighboring cells and return new dataframe with original channels and medians of the desired channels
myData2 <- findNeighbors(myData, 12)
# Save the data to a file
write.csv(myData2, file="Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist.csv", sep = ",",  row.names = FALSE, col.names = TRUE, quote = FALSE)
library("robustbase")
# Find all neighboring cells within a radius
findNeighbors <- function(myData, distance){
df <- myData
d <- distance
numNeighbors <- 0 # vector to store number of neighbors for each cell
# Add empty columns (numCol = numChannel*6 + 1) for nearest 6 cells and 5 channel data to the dataframe
# to store the average channel data and 'numNeighbors'
# number of CHANNEL data columns to be used (e.g., 5 => B220, CD3, CD4, CD8, CD31)
numChannels <- 5
# Create a new dataframe with the channel information, top 6 neighbors information(6), plus_distance, numNeighbors(1)
# and X(2), Y(3) coordinates, ID(7) columns
df2 <- cbind(df[,9:13], matrix(data=0, nrow = nrow(df), ncol = ((numChannels + 1)*6 +1)), df[,c(2,3,7)])
dim(df2)
# Add channel names to all columns containing neighbor cell info
colNames <- colnames(df[,9:13])
for (i in 1:6){ # 6 neighbors
for (j in 1:numChannels){
newCols <- paste0("nb", i, ".", colNames[j])
colNames <- c(colNames, newCols)
}
colNames <- c(colNames,paste0("nb", i, ".dist"))
}
colNames
# Add back additional columns to be included
colNames2 <- c(colNames, "numNeighbors", colnames(df[,c(2,3,7)]) )
length(colNames2)
names(df2) <- colNames2
cat(colnames(df2))
head(df2)
# Function to calculate distance
calDist <- function(x, y, X, Y){
dis <- sqrt((x-X)^2 + (y-Y)^2)
return(dis)
}
# Identify the neighboring cells within the distance 'd'
for (index in 1:nrow(df)){
X <- df[index, 'x']
Y <- df[index, 'y']
# Print out the progress status
message(paste0(index, "/", nrow(df), "\n"))
# find all neighboring cells within the DISTANCE
neighbors <- df[sqrt((df$x-X)^2 + (df$y-Y)^2) <= d & sqrt((df$x-X)^2 + (df$y-Y)^2) > 0,]
if(nrow(neighbors) > 0){
# Find distance between the target cell and its neighbors
neighbors$distance <- mapply(calDist, neighbors$x, neighbors$y, X, Y)
# Rank the neighboring cells based on distance
neighbors_ranked <- neighbors[order(neighbors$distance),]
# Add the number of neighboring cells to the dataframe
numNeighbors <- dim(neighbors)[1]
df2[index, "numNeighbors"] <- numNeighbors
# Add the closest 6 neighboring cells into the dataframe
if(nrow(neighbors_ranked) >= 6){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
df2[index,c(36:40)] <- neighbors_ranked[6,9:13]
df2[index, 41]      <- neighbors_ranked[6,'distance']
}
else if(nrow(neighbors_ranked) == 5){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
df2[index,c(30:34)] <- neighbors_ranked[5,9:13]
df2[index, 35]      <- neighbors_ranked[5,'distance']
}
else if(nrow(neighbors_ranked) == 4){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
df2[index,c(24:28)] <- neighbors_ranked[4,9:13]
df2[index, 29]      <- neighbors_ranked[4,'distance']
}
else if(nrow(neighbors_ranked) == 3){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
df2[index,c(18:22)] <- neighbors_ranked[3,9:13]
df2[index, 23]      <- neighbors_ranked[3,'distance']
}
else if(nrow(neighbors_ranked) == 2){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
df2[index,c(12:16)] <- neighbors_ranked[2,9:13]
df2[index, 17]      <- neighbors_ranked[2,'distance']
}
else if(nrow(neighbors_ranked) == 1){
df2[index, c(6:10)] <- neighbors_ranked[1,9:13]
df2[index, 11]      <- neighbors_ranked[1,'distance']
}
}
else{
# ignore if no neighbor found
# because the df2 has already pre-populated
}
}
return(df2)
}
# Find the neighboring cells and return new dataframe with original channels and medians of the desired channels
myData2 <- findNeighbors(myData, 12)
# Save the data to a file
write.csv(myData2, file="Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist.csv", sep = ",",  row.names = FALSE, col.names = TRUE, quote = FALSE)
library(Rtsne)
set.seed(42)
# Generate neighbor cell count distribution histograms
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_distribution.jpeg"), width=1200, height=1200)
hist(myData2[,"numNeighbors"], col="blue", cex.lab=3, cex.axis=3, cex.main=3, cex.sub=3)
dev.off()
## Generating tSNE plots with Top6 neighbors information
for(i in c(10,30,50,80,100))
{
# run tSNE analysis
rtsne_out2 <- Rtsne(as.matrix(myData2[,1:41]), check_duplicates = FALSE, perplexity = i)
#Create tSNE plot
jpeg(paste0("./plots/Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i,".jpeg"), width=1200, height=1200)
plot(rtsne_out2$Y, main=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i), xlab='tSNE dimension 1', ylab='tSNE dimension 2', type = "p", cex=2, col = "blue")
dev.off()
# Save tSNE plot coordiates
tSNE_plot_coords2 <- rtsne_out2$Y
rownames(tSNE_plot_coords2) <- rownames(myData2)
colnames(tSNE_plot_coords2) <- c("tSNE dimension 1", "tSNE dimension 2")
head(tSNE_plot_coords2)
write.csv(tSNE_plot_coords2, file=paste0("Domains_Ms1LN1_stat_tissue_d12_Top6_neighbors_with_dist_p", i, "_coords.csv"), row.names = FALSE, col.names = TRUE)
}
install.packages('nortest')
install.packages('plotrix')
shiny::runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
install.packages("profvis")
library(profvis)
profvis({
data(diamonds, package = "ggplot2")
plot(price ~ carat, data = diamonds)
m <- lm(price ~ carat, data = diamonds)
abline(m, col = "red")
})
runApp('TRIAGE/app')
runApp('TRIAGE/app')
profvis({
runExample(example = "06_tabsets", display.mode = "normal")
})
library(shiny)
profvis({
runExample(example = "06_tabsets", display.mode = "normal")
})
library(shiny)
profvis({
runExample(example = "06_tabsets", display.mode = "normal")
})
shiny::runApp('TRIAGE/app')
?try()
runApp('TRIAGE/app')
dataDir <<- "~/TRIAGE/app/data/"
## Complete list of all protein-encoding genes in human genome
## ftp://ftp.ebi.ac.uk/pub/databases/genenames/new/tsv/locus_types/gene_with_protein_product.txt
humanGenes <- read.table(file=paste0(dataDir, "HGNC_genes_with_protein_product_EntrezID_geneSymbole_lookup.txt"), sep="\t", header=TRUE)
## Complete list of all genes in mouse genome
## http://www.informatics.jax.org/downloads/reports/MGI_Gene_Model_Coord.rpt
mouseGenes <- read.table(file=paste0(dataDir, "Mouse_genes_with_protein_product_EntrezID_geneSymbol_lookup.txt"), sep="\t", header=TRUE)
?read.csv()
data <- read.csv('~/Desktop/EndoGenes_logInput.csv', header = TRUE, stringsAsFactors = FALSE)
if(!("EntrezID" %in% colnames(data)) && !("GeneSymbol" %in% colnames(data))){
# Input data do not have EntrezID AND GeneSymbol columns
showModal(modalDialog(
title=HTML("<h3><font color=#ff0000>Input file format error!</font></h3>"),
HTML("Your input file does not contain a required column named 'EntrezID' or 'GeneSymbol'. <br>Please fix your input file and try again!"),
easyClose = TRUE
))
Sys.sleep(5)
session$reload()
}else if(("GeneSymbol" %in% colnames(data)) & !("EntrezID" %in% colnames(data))) {
# Input data have 'GeneSymbol' column
# Get EntrezID from GeneSymbol
if(input$organism == "Human"){
library('org.Hs.eg.db')
x <- org.Hs.egSYMBOL2EG
backgroundGenes <- humanGenes
} else if(input$organism == "Mouse"){
library('org.Mm.eg.db')
x <- org.Mm.egSYMBOL2EG
backgroundGenes <- mouseGenes
}
mapped_genes <- mappedkeys(x)
overlappingGenes <- intersect(as.character(as.list(mapped_genes)), as.character(data$GeneSymbol))
# If no overlapping genes found, catch and handle the error
if(length(overlappingGenes) == 0){
showModal(modalDialog(
title=HTML("<h3><font color=#ff0000>Organism - Gene Set MISMATCH!</font></h3>"),
HTML("The organism you selected and the organism from which the input data generated do not match. Please select the correct organism or a different input file, then try again"),
easyClose = TRUE
))
}
# Get background genes that are not in the input data
df_backgroundGenes <<- backgroundGenes[!backgroundGenes$GeneSymbol %in% data$GeneSymbol,]
xx <- as.list(x[overlappingGenes])
y <- unlist(xx)
y <- data.frame(GeneSymbol = names(y), EntrezID = y, row.names = NULL, stringsAsFactors=FALSE)
numGeneInInput <- nrow(data)
if(length(overlappingGenes) > 0){
tempData <- merge(x=data, y=y, by="GeneSymbol")
data <- tempData
}
numGeneWithEntrezID <- nrow(data)
# Display a warning if one or more input genes have no matching EntrezID due obsolete GeneSymbol
if((numGeneInInput - numGeneWithEntrezID) > 1){
showModal(modalDialog(title="Warning:", HTML("<h3><font color=red>Only"), numGeneWithEntrezID,HTML("/"),numGeneInInput, HTML("GeneSymbols have mapped EntrezIDs and will be used in this analysis!</font><h3><br>"),
HTML("Either check the organism or update your GeneSymbols to match the official <a href='https://www.genenames.org/cgi-bin/symbol_checker' target=_blank>HGNC</a> symbols if you want to include ALL in this analysis.")))
}
# Switch/reorder 'EntrezID' to the FIRST column
data = data[, c(ncol(data), 1:(ncol(data) - 1))]
rm(tempData,x,y,xx)
message("Input file has a 'GeneSymbol' column!")
}
else if(("EntrezID" %in% colnames(data)) & !("GeneSymbol" %in% colnames(data))){
# Input data have 'EntrezID' column (No 'GeneSymbol' column)
# Get 'GeneSymbol' from 'EntrezID'
if(input$organism == "Human"){
library('org.Hs.eg.db')
x <- org.Hs.egSYMBOL
backgroundGenes <- humanGenes
} else if(input$organism == "Mouse"){
library('org.Mm.eg.db')
x <- org.Mm.egSYMBOL
backgroundGenes <- mouseGenes
}
mapped_genes <- mappedkeys(x)
overlappingGenes <- intersect(mapped_genes, data$EntrezID)
# If no overlapping genes found, catch and handle the error
if(length(overlappingGenes) == 0){
showModal(modalDialog(
title=HTML("<h3><font color=#ff0000>Organism - Gene Set MISMATCH!</font></h3>"),
HTML("The organism you selected and the organism from which the input data were generated do not match. Please select the correct organism or a different input file, then try again"),
easyClose = TRUE
))
}
# Get background genes that are not in the input data
df_backgroundGenes <<- backgroundGenes[!backgroundGenes$EntrezID %in% data$EntrezID,]
xx <- as.list(x[!is.na(overlappingGenes)])
y <- unlist(xx)
y <- data.frame(GeneSymbol = y, EntrezID = names(y), row.names = NULL, stringsAsFactors=FALSE)
if(length(overlappingGenes) > 0){
# Create a dataframe of the input data with both EntrezID and GeneSymbol
tempData <- merge(x=data, y=y, by="EntrezID")
data <- tempData
}
# Switch/reorder 'EntrezID' to the FIRST column
data = data[, c(ncol(data), 1:(ncol(data) - 1))]
rm(tempData,x,y,xx)
message("Input file has a 'EntrezID' column!")
# Having both EntrezID and GeneSymbol
}else{
if(input$organism == "Human"){
backgroundGenes <- humanGenes
} else if(input$organism == "Mouse"){
backgroundGenes <- mouseGenes
}
# Get background genes that are not in the input data
df_backgroundGenes <<- backgroundGenes[!backgroundGenes$EntrezID %in% data$EntrezID,]
# Switch/reorder 'EntrezID' to the FIRST column
data = data[, c(ncol(data), 1:(ncol(data) - 1))]
message("Input file has both 'EntrezID' and 'GeneSymbol' columns!")
}
# Populate GeneSymbolcolumn with EntrezIDs if the corresponding GeneSymbols are not available
for (i in 1:nrow(data)){
if(is.na(data$GeneSymbol[i])){
data$GeneSymbol[i] <- data$EntrezID[i]
}
}
# Make sure the EntrezIDs are integers
data$EntrezID <- as.integer(data$EntrezID)
data <- data[order(data$EntrezID),]
# Make a copy of the original input data for later use
siRNA.Score <<- data
data <- data %>%
dplyr::select(GeneSymbol, everything())
# display the input file dimension
datatable(data, rownames = FALSE, options = list(paging=TRUE))
})
input$cutoff_valueM <- 0.01
input$cutoff_valueM <- 0.001
siRNA.Score <<- data
backgroundGenes <- mouseGenes
df_backgroundGenes <<- backgroundGenes[!backgroundGenes$GeneSymbol %in% data$GeneSymbol,]
xx <- as.list(x[overlappingGenes])
y <- unlist(xx)
y <- data.frame(GeneSymbol = names(y), EntrezID = y, row.names = NULL, stringsAsFactors=FALSE)
numGeneInInput <- nrow(data)
library('org.Mm.eg.db')
x <- org.Mm.egSYMBOL2EG
backgroundGenes <- mouseGenes
mapped_genes <- mappedkeys(x)
overlappingGenes <- intersect(as.character(as.list(mapped_genes)), as.character(data$GeneSymbol))
df_backgroundGenes <<- backgroundGenes[!backgroundGenes$GeneSymbol %in% data$GeneSymbol,]
xx <- as.list(x[overlappingGenes])
y <- unlist(xx)
y <- data.frame(GeneSymbol = names(y), EntrezID = y, row.names = NULL, stringsAsFactors=FALSE)
numGeneInInput <- nrow(data)
if(length(overlappingGenes) > 0){
tempData <- merge(x=data, y=y, by="GeneSymbol")
data <- tempData
}
numGeneWithEntrezID <- nrow(data)
data = data[, c(ncol(data), 1:(ncol(data) - 1))]
rm(tempData,x,y,xx)
# Get background genes that are not in the input data
df_backgroundGenes <<- backgroundGenes[!backgroundGenes$EntrezID %in% data$EntrezID,]
# Switch/reorder 'EntrezID' to the FIRST column
data = data[, c(ncol(data), 1:(ncol(data) - 1))]
for (i in 1:nrow(data)){
if(is.na(data$GeneSymbol[i])){
data$GeneSymbol[i] <- data$EntrezID[i]
}
}
data$EntrezID <- as.integer(data$EntrezID)
data <- data[order(data$EntrezID),]
siRNA.Score <<- data
data <- data %>%
dplyr::select(GeneSymbol, everything())
input$cutoff_valueM <- 0.01
input$cutoff_valueM <- 0.001
input[cutoff_valueM] <- 0.01
input[cutoff_valueM] <- 0.001
input[['cutoff_valueM']] <- 0.01
input[['cutoff_valueM']] <- 0.001
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
runApp('TRIAGE/app')
library(shiny)
library(profvis)
profvis({
runApp()
})
library(shiny)
library(profvis)
setwd("~/TRIAGE/app")
profvis({
runApp()
})
profvis({
runApp()
})
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
