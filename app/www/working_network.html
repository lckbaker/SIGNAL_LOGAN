<html>
  <meta charset="utf-8">
  <head>
    <style>
    path.arc {
              cursor: move;
              fill: #fff;
            }

            .node {
              font-size: 10px;
              !font-weight: normal;
            }

            .node:hover {
              !fill: #1f77b4;
              cursor: crosshair;
            }

            .link {
              fill: none;
              !stroke: #1f77b4;
              stroke-opacity: .1;
              pointer-events: none;
            }

            .link.source, .link.target {
              !stroke-opacity: 1;
              stroke-width: 2px;
            }

            .node.target {
              !fill: #d62728 !important;
              !font-weight: bold;
            }

            .link.source {
              !stroke: #d62728;
            }

            .node.source {
              !fill: #2ca02c;
              !font-weight: bold;
            }

            .link.target {
              !stroke: #2ca02c;
            }

            .pathButton {
              cursor: pointer;
            }

            .resetButton {
              cursor: pointer;
            }

            .networkGraph{
            }
    </style>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://mbostock.github.io/d3/talk/20111116/d3/d3.js"></script>
    <script src="https://mbostock.github.io/d3/talk/20111116/d3/d3.layout.js"></script>
  </head>
  <body>
    <script>
      // input output from R console from variable json_1 defined in Ranking_source.R
      // var json_data =

      var df = []

      json_data.forEach(function(d){
        d = {name: d.name[0], imports: d.imports, weights: d.weights,
              datasource: d.datasource, Confidence: d.Confidence[0], color: d.Color[0]};
        df.push(d)
      });

      console.log(df);

      var w = 800,
        h = w,
        rx = 380,
        ry = 365,
        m0,
        rotate = 0,
        headSpace = 100,
        rectW = w-640,
        rectH = w-650;

      var clickedData = [],
          splines = [],
          childrenData = {},
          childrenArray = [];

      //var colorMap = ['#ff0000', '#ff8000', '#00ff80', '#0080ff'];

      var novelColor = "green",
          color1 = "blue",
          color2 = "red",
          color3 = "saddlebrown",
          color12 = "#a09d01",
          color13 = "#ce6702",
          color23 = "#6b5b3e",
          color123 = "#62476d",
          colorMap = [color1, color2, color3, novelColor, color123, color12, color23, color13],
          windowFields = ['Gene Name:', ' ', 'Interactions:', 'Confidence:'];

      /*var uniquePathways = function(df){
        var lookup = {};
        var result = [];

        for (var i = 0; i<df.length; i++) {
          var name = df[i].parent.name;

          if (!(name in lookup)) {
            lookup[name] = 1;
            if(name === 'Novel'){
              result.push('Novel Genes');
            }
            result.push(name);
          }
        }

        result.sort();
        result.push(result.splice(result.indexOf('Novel Genes'), 1)[0]);

        return(result)
      }*/

      var cluster = d3.layout.cluster()
        .size([360, ry - 120]);
        //.sort(function(a, b) { return d3.ascending(a.key, b.key); });

      var bundle = d3.layout.bundle();

      var line = d3.svg.line.radial()
        .interpolate("bundle")
        .tension(.85)
        .radius(function(d) { return d.y; })
        .angle(function(d) { return d.x / 180 * Math.PI; });

      // Chrome 15 bug: <http://code.google.com/p/chromium/issues/detail?id=98951>
      var div = d3.select('body').insert("div")
        .attr("class", "d3network")
        .style("top", headSpace + "px")
        //.style("left", "0px")
        .style("width", w + "px")
        .style("height", w + "px")
        .style("position", "absolute")
        .style("-webkit-backface-visibility", "hidden");

      var svG = div.append("svg:svg")
        .attr("width", w)
        .attr("height", w)

      var legend = svG.append("svg:g")
        .attr("transform", "translate(5,5)")

      var svg = svG.append("svg:g")
        //.attr("x", rx)
        //.attr("y", ry)
        .attr("class", "networkGraph")
        //.attr("transform", "translate(" + rx + "," + ry + ")rotate(-30)");

      var windowArea = svG.append("svg:g")
        .attr("transform", "translate(638,5)")

      windowArea.append("svg:rect")
        .attr("height", rectH)
        .attr("width", rectW)
        .attr("rx", 5)
        .attr("ry", 5)
        .style("stroke", novelColor)
        .style("fill", "none")
        .style("stroke-width", 2);

      var dubsMessage = svG.append("svg:g")
        .attr("transform", "translate(685, 170)")
        .attr("class", "resetButton");

      dubsMessage.append("svg:rect")
        .attr("height", 20)
        .attr("width", 107)
        .attr("rx", 10)
        .attr("ry", 10)
        .style("stroke", "black")
        .style("fill", "none")
        .style("stroke-width", 2);

      dubsMessage.append("svg:text")
        //.style("font-size", "12px")
        .attr("font-family", "Helvetica")
        .style("text-anchor", "center")
        .attr("dy", 15)
        .attr("dx", 5)
        .text('Click to reset')

      d3.select(".resetButton").on("click", mousedbl);

      /*dubsMessage.append("svg:text")
        .style("font-size", "12px")
        .attr("dy", "1em")
        .text('to reset')*/

      var windowText = windowArea.selectAll("text")

      windowText.data(windowFields)
        .enter()
          .append("svg:text")
          .attr("class", "vizText")
          .style("fill", "black")
          .attr("transform", function(d) { return "translate(0,20)"; })
          .attr("font-family", "Helvetica")
          .attr("dy", function(d,i){return(20*i)})
          .attr("dx", 2)
          .text(function(d) { return d; });

      var pathButton = svG.append("svg:g")
        .attr("transform", "translate(710, 200)")
        .attr("class", "pathButton")

      pathButtonTxt = ["Highlight", "Clicked", "Pathways"]

      pathButton.selectAll("text")
        .data(pathButtonTxt)
        .enter()
          .append("svg:text")
          //.attr("class", "pathButton")
          .style("text-anchor", "center")
          .attr("dx", 5)
          .attr("dy", function(d, i){return 16*i + 16;})
          .attr("font-family", "Helvetica")
          .text(function(d){return d;});

      pathButton.append("svg:rect")
        .attr("height", 55)
        .attr("width", 80)
        .attr("rx", 10)
        .attr("ry", 10)
        //.attr("class", "pathButton")
        .style("stroke", "black")
        .style("fill", "none")
        .style("stroke-width", 2)
        //.on("click", drawConnections);

      /*.append("svg:text")
        .attr("dy", 14)
        .attr("dx", 1)
        .style("font-size", "12px")
        .attr("font-family", "Helvetica")
        .text("Highlight Clicked Pathways")*/

      d3.select('.pathButton').on("click", drawConnections)

      svg.append("svg:path")
        .attr("class", "arc")
        .attr("d", d3.svg.arc().outerRadius(ry - 120).innerRadius(0).startAngle(0).endAngle(2 * Math.PI))
        //.on("mousedown", mousedown);

      // testing data for console development
      // var myurl = "https://gist.githubusercontent.com/mbostock/1044242/raw/3ebc0fde3887e288b4a9979dad446eb434c54d08/flare.json"
      // var json_flare = await $.getJSON(myurl)

      // find all names of parentNames
      function findParents(classes){
        var map = {};

        function find(data){
          map[data.parent.name] = data.parent.name;
        }

        classes.forEach(function(d) {
          find(d);
        })

        arr = Object.keys(map);
        arr.push(arr.splice(arr.indexOf("Novel"), 1)[0]);

        return arr;
      }

      // Lazily construct the package hierarchy from class names.
      function root(classes) {
        var map = {};

        function find(name, data) {
          var node = map[name], i;
          if (!node) {
            node = map[name] = data || {name: name, children: []};
            if (name.length) {
              node.parent = find(name.substring(0, name.indexOf(".")));
              node.parent.children.push(node);
              node.key = name.substring(name.lastIndexOf(".") + 1);
            }
          }
          return node;
        }

        classes.forEach(function(d) {
          find(d.name, d);
        });

        return map[""];
      }

      // Return a list of imports for the given array of nodes.
      function imports(nodes) {
        var map = {},
            imports = [];

        // Compute a map from name to node.
        nodes.forEach(function(d) {
          map[d.name] = d;
        });

        // For each import, construct a link from the source to target node.
        nodes.forEach(function(d) {
          if (d.imports) d.imports.forEach(function(i) {
            imports.push({source: map[d.name], target: map[i]});
          });
        });

        return imports;
      }

      var nodes = cluster.nodes(root(df)),
          links = imports(nodes),
          splines = bundle(links),
          parents = findParents(df);

      /*else if(pathwayNames.length === 3){
        colorMapt = colorMap.slice(0,2)
        colorMapt.push(colorMap[3])
        colorMap = colorMapt
      }*/

      /*var daMaps = colorMap.slice(0,1)

      daMaps.push(novelColor)*/

      var numbNovel = 0;
      var numbNoNovel = 0;
      for(i in df){
        if(df[i].parent.name == "Novel"){
          numbNovel ++;
        }
        else{
          numbNoNovel ++;
        }
      }
      var shiftRotate = -(numbNoNovel)/(numbNovel + numbNoNovel) * 180;

      svg.attr("transform",  "translate(" + rx + "," + ry + ")rotate(" + shiftRotate + ")")


      var colorMapping = function(df){
        newCols = []
        for(i in df){
          if(!(newCols.includes(df[i].color))){
            newCols.push(df[i].color)
          }
        }
        newCols.splice(newCols.indexOf(novelColor), 1);
        newCols.push(novelColor);
        return newCols;
      }

      startingColors = colorMapping(df)

      var ordColors = []

      for(j in colorMap){
        if(startingColors.includes(colorMap[j])){
          ordColors.push(colorMap[j])
        }
      }

      var novelInd = ordColors.indexOf(novelColor)

      var getLegendColors = function(){
        check = 0
        for(i in parents){
          if(parents[i].includes(" & ")){
            check = 1
          }
        }
        if(check){
          lColors = ["#000000"];
          lColors = lColors.concat(ordColors.slice(0, novelInd+1));
          lColors.push("#000000", "#000000", "#000000");
          lColors = lColors.concat(ordColors.slice(novelInd+1));
        }
        else{
          lColors = ordColors;
        }
        return lColors;
      }

      var legendColors = getLegendColors()

      var pathwayNames = parents.slice(0);

      /*colorMapt = colorMap.slice(0, parents.length - 1)
      colorMapt.push(colorMap[7])
      colorMap = colorMapt.slice(0)*/

      /*var colorText = function(d){
        for(i in parents){
          if(d === parents[i]){
            return colorMap[i];
          }
        }
      }*/

      /*var loopColors = function(color, s){


      }*/

      var fixPathwayNames = function(pns){
        pathways = ["Pathways:"]
        overlaps = [" ", "Genes in Overlapping", "Pathways:"]
        abc = ["1: ", "2: ", "3: "]
        abcs = ["1 & 2", "1 & 3", "2 & 3", "1 & 2 & 3"]
        n = startingColors.length
        pns = pns.slice(0)
        check = 0
        for(i in pns){
          if(pns[i].includes(" & ")){
            check = 1
          }
        }
        if(!check){
          pns[pns.length-1] = "Novel Genes"
        }
        else{
          for(s in ordColors){
            color = ordColors[s]
            switch (color) {
              case color1:
                nS = abc[0] + pns[startingColors.indexOf(color)];
                pathways.push(nS)
                break;
              case color2:
                nS = abc[1] + pns[startingColors.indexOf(color)];
                pathways.push(nS)
                break;
              case color3:
                nS = abc[2] + pns[startingColors.indexOf(color)];
                pathways.push(nS)
                break;
              case novelColor:
                nS = "Novel Genes";
                pathways.push(nS)
                break;
              case color12:
                nS = abcs[0];
                overlaps.push(nS)
                break;
              case color13:
                nS = abcs[1];
                overlaps.push(nS)
                break;
              case color23:
                nS = abcs[2];
                overlaps.push(nS)
                break;
              case color123:
                nS = abcs[3];
                overlaps.push(nS)
                break;
            }
            // (s <= novelInd) ? pathways.push(nS) : overlaps.push(nS);
          }




          /*for(i in pns){
            if(!(pns[i].includes(" & "))){
              pathways.push(pns[i])
            }
          }
          // sorting out pathways first
          pathLength = pathways.length
          newAbc = abc.slice(0, pathLength-1)
          newAbc.push("")
          for(s in newAbc){
            pathways[s] = newAbc[s] + pathways[s]
          }
          pathways.splice(pathways.indexOf("Novel"), 1, "Novel Genes")
          pathways.splice(0, 0, "Pathways:")*/

          // now sorting overlaps
          /*overlapMaps = startingColors.slice(novelInd+1)
          if(overlapMaps.includes(color12)){
            overlaps.push(abcs[0])
          }
          if(overlapMaps.includes(color13)){
            overlaps.push(abcs[1])
          }
          if(overlapMaps.includes(color23)){
            overlaps.push(abcs[2])
          }
          if(overlapMaps.includes(color123)){
            overlaps.push(abcs[3])
          }*/

          // bringing them together
          pnsSort = pathways.concat(overlaps)
          pns = pnsSort
        }
        return pns;
      }



        /*abc = ["1: ", "2: ", "3: ", ""]
        check = 0
        for(i in pns){
          if(pns[i].includes(" & ")){
            check = 1
          }
        }
        if(!check){
          pns[pns.length-1] = "Novel Genes"
        }
        else{
          // slice is used to create a seperate copy of the arrays
          pnsSort = pns.slice(0)
          //pnsInd = []
          abcs = ["1 & 2", "1 & 3", "2 & 3", "1 & 2 & 3"]
          pnsShorts = []
          pnsLongs = []
          pnsShortInds = []
          pnsLongInds = []
          for(i in pns){
            if(pns[i].includes(" & ")){
              pnsLongInds.push(i)
              pnsLongs.push(pns[i])
            }
            else{
              pnsShortInds.push(i)
              pnsShorts.push(pns[i])
            }
          }
          pnsInd = pnsShortInds.slice(0)
          /*cmInd = []
          for(p in pnsLongInds){
            cmInd = pnsInd.splice(pnsInd.length-1, 0, pnsLongInds[p]).concat(cmInd)
          }
          colorMap = pnsInd.map((item) => (colorMap[item]))
          pnsSort = pnsShortInds.map((item) => pnsSort[item])
          for(s in pnsShortInds){
            pnsSort[s] = abc[s] + pnsSort[s]
          }
          //cm = pnsShorts.map((item) => colorMap[item])
          for(k in pnsLongs){
            inds = []
            for(s in pnsSort){
              if(pnsLongs[k] == pns[s]){
                dummyStrings = pns[s].split(" & ")
                for(j in dummyStrings){
                    whichInds = pnsShorts.indexOf(dummyStrings[j])
                    inds.push(whichInds)
                }
              }
            }
            if([0,1].every(r => inds.includes(r)) && inds.every(r => [0,1].includes(r))){
              pnsSort.splice(pnsSort.length, 0, abcs[0])
            }
            else if([0,2].every(r => inds.includes(r)) && inds.every(r => [0,2].includes(r))){
              pnsSort.splice(pnsSort.length, 0, abcs[1])
            }
            else if([1,2].every(r => inds.includes(r)) && inds.every(r => [1,2].includes(r))){
              pnsSort.splice(pnsSort.length, 0, abcs[2])
            }
            else if([0,1,2].every(r => inds.includes(r))){
              pnsSort.splice(pnsSort.length, 0, abcs[3])
            }
          }
          // fixing order
          pnsSortInds = {}
          for(var i = 0; i < pnsSort.length; i++){
            if(pnsSort[i].includes("&")){
              if(pnsSort[i].includes("1") && pnsSort[i].includes("2") && pnsSort[i].includes("3")){
                pnsSortInds[123] = i
              }
              else if(pnsSort[i].includes("1") && pnsSort[i].includes("2")){
                pnsSortInds[12] = i
              }
              else if(pnsSort[i].includes("1") && pnsSort[i].includes("3")){
                pnsSortInds[13] = i
              }
              else if(pnsSort[i].includes("2") && pnsSort[i].includes("3")){
                pnsSortInds[23] = i
              }
            }
          }
          pnsNewInds = []
          for (var i = 0; i != pnsShorts.length; ++i) pnsNewInds.push(i)
          pnsNewInds = pnsNewInds.concat(Object.values(pnsSortInds))
          pnsSort = pnsNewInds.map((item) => pnsSort[item])
          /*for(var j = 0; j <= pnsMax-pnsMin; i++){
            pnsSort.splice(j, 1, pnsSort)
          }
          // adding more words to legendtext
          pnsSort.splice(pnsSort.indexOf("Novel"), 1, "Novel Genes")
          pnsSort.splice(0, 0, "Pathways:")
          pnsSort.splice(pnsShorts.length+1, 0, " ")
          pnsSort.splice(pnsShorts.length+2, 0, "Genes in Overlapping")
          pnsSort.splice(pnsSort.indexOf("Genes in Overlapping")+1, 0, "Pathways:")
          pns = pnsSort
        }
        return pns;
      }*/

      pathwayNames = fixPathwayNames(pathwayNames);

      /*var getLegendColors = function(){
        novelInd = startingColors.indexOf(novelColor)
        n = startingColors.length - 1
        m = startingColors.slice(novelInd+1).length
        check = 0
        if(m > 0){
          check = 1
        }
        if(!check){
          return startingColors;
        }

      }



        /*legendColors = ["#000000", startingColors[0]]
        for(s in pws){
          if(pws[s].includes("2:")){
            legendColors.push(colorMap[1])
          }
          else if(pws[s].includes("3:")){
            legendColors.push(colorMap[2])
          }
          else if(pws[s] === "Novel Genes"){
            legendColors.push(colorMap[7])
          }
          else if(pws[s] === " "){
            legendColors.push("#000000")
          }
          else if(pws[s] === "Genes in Overlapping"){
            legendColors.push("#000000", "#000000")
          }
          if(pws[s] === "1 & 2"){
            legendColors.push(colorMap[3])
          }
          else if(pws[s] === "1 & 3"){
            legendColors.push(colorMap[4])
          }
          else if(pws[s] === "2 & 3"){
            legendColors.push(colorMap[5])
          }
          else if(pws[s] === "1 & 2 & 3"){
            legendColors.push(colorMap[6])
          }
        }
        return legendColors;
      }

      lColors = getLegendColors();*/

      /*var uniquePathways = function(df){
        var lookup = {};
        var result = [];

        for (var i = 0; i<df.length; i++) {
          var name = df[i].parent.name;

          if (!(name in lookup)) {
            lookup[name] = 1;
            if(name === 'Novel'){
              result.push('Novel Genes');
            }
            result.push(name);
          }
        }

        result.sort();
        result.push(result.splice(result.indexOf('Novel Genes'), 1)[0]);

        return(result)
      }*/

      legend.selectAll("text")
        .data(pathwayNames)
        .enter()
        .append("svg:text")
        .style("fill", function(d, i) {return legendColors[i];})
        .attr("id", function(d, i){return 'text' + i})
        .attr("transform", function(d) {return "translate(0,20)";})
        .attr("font-family", "Helvetica")
        .attr("dy", function(d,i) {
          return 20*i
        })
        .text(function(d) { return d; });

      //legendText
        /*.attr("dx", function(d,i) {
          if(i>2 && i%2 === 1 && i!==(pathwayNames.length-1)){
            return 340;
          }
          else{
            return 0;
          }
        })
        .style("font-size", function(){
          return (Math.min(1/Math.log10(parents.length)*10, 14))
        })*/

      var path = svg.selectAll("path.link")
          .data(links)
        .enter().append("svg:path")
          .attr("class", function(d) { return "link source-" + d.source.key + " target-" + d.target.key; })
          .attr("d", function(d, i) { return line(splines[i]); })
          .style('stroke', function(d) {
            if(d.source.parent.name === 'Novel'){
              return d.target.color;
            }
            else{
              return d.source.color;
            }
          })
          .style("stroke-opacity", 0.05);
          //.attr("transform", function(d) { return "rotate(" + (d.x - 110) + ")"});

      var allNodes = svg.selectAll("g.node")
          .data(nodes.filter(function(n) { return !n.children; }))
        .enter().append("svg:g")
          .attr("class", "node")
          .attr("id", function(d) { return "node-" + d.key; })
          .attr("parentNode", function(d) { return d.parent.name;})
          .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; });

      allNodes.append("svg:circle")
          //.attr("cx", function (d) { return d.x; })
          //.attr("cy", function (d) { return d.y; })
          //.attr("r", function (d) { return 1; })
          .attr("r", Math.min(1/Math.log10(df.length)*5, 4))
          .style("fill", function(d) { return d.color; })
          .on("mouseover", mouseover)
          .on("mouseout", mouseout)
          .on("click", mouseclick);

      allNodes.append("svg:text")
          .style("fill", function(d){ return d.color;})
          .style("font-size", function(){
            return Math.min(1/Math.log10(df.length)*15, 14)
          })
          .attr("font-family", "HelveticaNeue-Light")
          .attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
          .attr("dy", ".31em")
          .attr("text-anchor", function(d) { return d.x < 180? "start" : "end"; })
          .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
          .text(function(d) { return d.key; })

      var still = false;

      svg.on("dblclick", mousedbl);

      d3.select("input[type=range]").on("change", function() {
        line.tension(this.value / 100);
        path.attr("d", function(d, i) { return line(splines[i]); });
      });

      /*d3.select(window)
        .on("mousemove", mousemove)
        .on("mouseup", mouseup);*/

      svg.on("mousemove", mousemove)
        .on("mousedown", mousedown)
        .on("mouseup", mouseup);

      function mouse(e) {
        console.log(e.pageX - rx)
        console.log(e.pageY - ry)
        return [e.pageX - rx, e.pageY - ry];
      }

      function mousedown() {
        m0 = mouse(d3.event);
        d3.event.preventDefault();
      }

      function mousemove() {
        if (m0) {
          var m1 = mouse(d3.event),
              dm = Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI,
              //rotate =+ dm;
              rotate1 = rotate ? rotate+dm : dm+shiftRotate;
              //rotate = shiftRotate
              //rotate += dm

          svg.style("-webkit-transform", "translateX(" + rx + "px)translateY(" + ry + "px)rotateZ(" + rotate1 + "deg)");
        }
      }

      function mouseup() {
        if (m0) {
          var m1 = mouse(d3.event),
              dm = Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;

          rotate = rotate ? rotate+dm : dm+shiftRotate;
          if (rotate > 360) rotate -= 360;
          else if (rotate < 0) rotate += 360;
          m0 = null;

          //div.style("-webkit-transform", null);
          svg.style("-webkit-transform", null);

          svg.attr("transform", "translate(" + rx + "," + ry + ")rotate(" + rotate + ")")
              //.attr("transform", "rotate(" + rotate + ")")
            .selectAll("g.node text")
              .attr("dx", function(d) { return (d.x + rotate) % 360 < 180 ? 8 : -8; })
              .attr("text-anchor", function(d) { return (d.x + rotate) % 360 < 180 ? "start" : "end"; })
              .attr("transform", function(d) { return (d.x + rotate) % 360 < 180 ? null : "rotate(180)"; });
        }
      }

      function mouseover(d) {
        if(!still){
          if(!d.clicked){
            if(clickedData.length === 0 || childrenArray.indexOf(d.name) > -1){
              /*svg.select("#node-" + d.key)
                  .style('font-weight', 'bold');*/
              setvals(d, true, false);
            }
            if(clickedData.length === 0){
              d3.selectAll(".vizText").remove()
              //geneFamily = fixStrings(d.parent.name)
              paintWindow(d, 1);
            }
            else if(childrenArray.indexOf(d.name) > -1){
              d3.selectAll(".vizText").remove()
              paintWindow(d, 3);
            }
          }
          else{
              setvals(d, true)
              /*svg.select("#node-" + d.key)
                  .style('font-weight', 'bold');*/
          }
        }
      }

      function mouseout(d) {
        if(!still){
          var i = clickedData.length>1 ? clickedData.length-1 : 0;
          if(!d.clicked){
            setvals(d, false);
            /*svg.select("#node-" + d.key)
                .style('font-weight', 'normal');*/
            if(clickedData.length>=1){
              setvals(clickedData[i], true, false)
            }
          }
          else if(clickedData.length === 1){
            setvals(d, true, false)
            setvals(clickedData[i], true, false)
          }
          if(clickedData.length === 0){
            clearVizText()
          }
          else{
            d3.selectAll(".vizText").remove()
            paintWindow(d, 2);
          }
        }
      }

      function mouseclick(d){
        if(!still){
          d.clicked = !d.clicked && true;

          clickedData.push(d)

          if(d.clicked){
            removelinks()

            setvals(d, true, false)

            d3.selectAll(".vizText").remove()

            paintWindow(d, 1);

            updateChildren(d)

            childrenArray = childrenData[d.name][0]
          }
          else if(clickedData[clickedData.length-1].name === d.name){
            setvals(d, true, false)
          }
          else{
            clickedData.pop()

            updateChildren(d, true)

            setvals(d, false, false)
          }
        }
      }

      function mousedbl(){
        childrenData = {}
        childrenArray = []
        still = false

        svg.selectAll("path.link")
            .style("stroke-opacity", 0.05)

        if(clickedData.length>0){
          for(var i in clickedData){
            setvals(clickedData[i], false, false)
            clickedData[i].clicked = false
            /*svg.select("#node-" + clickedData[i].key)
                .style('font-weight', 'normal');*/
          }
          clickedData = []
        }

        svg.selectAll(".node text")
          .style("font-weight", "normal")
          .style("opacity", 1)

        svg.selectAll(".node circle").style('opacity', 1)

        svg.attr("transform",  "translate(" + rx + "," + ry + ")rotate(" + shiftRotate + ")")
        rotate = shiftRotate;
        clearVizText()
      }

      function clearVizText(){
        d3.selectAll(".vizText").remove()
        windowFields = ['Gene Name:', ' ',
                        'Interactions:',
                        'Confidence:']
        windowText.data(windowFields)
          .enter()
            .append("svg:text")
            .attr("class", "vizText")
            .style("fill", "black")
            .attr("font-family", "Helvetica")
            .attr("transform", function(d) { return "translate(0,20)"; })
            .attr("dy", function(d,i){return(20*i)})
            .attr("dx", 2)
            .text(function(d) { return d; });
      }


      function updateChildren(d, remove=false){
        childrenArray = []

        if(!remove){
          childrenData = {[d.name]: [d.imports]}
        }
        else{
          delete childrenData[d.name]
        }
      }

      /*linkColorFunc = function(d){
        hits = d.imports
        hitColors = []
        if(d.parent.name === 'Novel Genes'){
          for(i in hits){
            for(j in df){
              if(df[j].key === hits[i].split('.')[1]){
                hitColors.push(df[j].color)
              }
            }
          }
          return hitColors;
        }
      }*/

      /*updateColors = function(d, val){
        hits = d.imports
        hitColors = []
        if(val){
          for(i in hits){
            for(j in df){
              if(df[j].name === hits[i]){
                hitColors.push(df[j].color)
              }
            }
          }
        }
        else{
          hitColors = Array(hits.length).fill(defLinkColor)
        }
        return(hitColors)
      }*/

      function setvals(d, val, block=true, pop=8){
        if(block){
          if(svg.selectAll("path.link.target-" + d.key).classed("target") === val){
            return;
          }
        }

        svg.selectAll("path.link.target-" + d.key)
            .classed("target", val)
            .style("stroke-opacity", val*.95 + .05)
            .each(updateNodes("source", val, pop));

        svg.selectAll("path.link.source-" + d.key)
            .classed("source", val)
            .style("stroke-opacity", val*.95 + .05)
            .each(updateNodes("source", val, pop));

        svg.selectAll(".node.source text")
            .filter(function(){
              return d3.select(this).attr("dx") == 8
            })
            .attr("dx", pop*val + pop)
            .style("font-weight", "bold")

        svg.selectAll(".node.source text")
            .filter(function(){
              return d3.select(this).attr("dx") == -8
            })
            .attr("dx", -pop*val - pop)
            .style("font-weight", "bold")

        svg.selectAll(".node")
            .filter(function(){
              return d3.select(this).select(" text").attr("dx") > 8 && d3.select(this).attr("class") === "node";
            })
            .selectAll(" text")
            .attr("dx", 8)
            .style("font-weight", "normal")

        svg.selectAll(".node")
            .filter(function(){
              return d3.select(this).select(" text").attr("dx") < -8 && d3.select(this).attr("class") === "node";
            })
            .selectAll(" text")
            .attr("dx", -8)
            .style("font-weight", "normal")

      }

      function updateNodes(name, value) {
        return function(d) {
          if (value) this.parentNode.appendChild(this);

          lastclicked = clickedData[clickedData.length-1];
          nodeBold = value || lastclicked===d[name] ? 'bold' : 'normal';

          svg.select("#node-" + d[name].key)
            .classed(name, value)
            /*.select(" text")
              .attr("dx", function(d){
                if(d.dx === "8" ){
                  return 14;
                }
                else if(d.dx === "-8"){
                  return -14;
                }
                else{
                  return pop*value + pop;
                }
              })*/
            //.style('font-weight', nodeBold);

          /*svg.selectAll("#node-" + d[name].key + " text")
            .attr("dx", function(d){
              deeX = svg.select("#node-" + d[name].key + " text").attr("dx")
              if(deeX === "8" ){
                return 14;
              }
              else if(deeX === "-8"){
                return -14;
              }
            })
            .style('font-weight', nodeBold);*/

          //console.log(d[name].key);

          //rotate = rotate ? shiftRotate : rotate;

          /*svg.select("#node-" + d[name].key + " text")
              //.attr("dx", 15)
              .attr("dx", function(d) { return d.dx === "-8" ? pop*value*(-1) - pop : pop*value + pop; })
              //.attr("dx", function(d) { return pop*value+pop})
              //.attr("dy", function(d) { return d.y + pop })
              //.attr("dx", function(d) { return (pop)})
              //.attr("text-anchor", function(d) { return (d.x + rotate) % 360 < 180 ? "start" : "end"; })
              //.transition(200)
              //.attr("transform", function(d) { console.log(d.dx); return "translate(" + d.dx+pop + "," + pop + ")"; })
              //.attr("transform", function(d) { return (d.x + rotate) % 360 < 180 ? null : "translate(5,5)"; })
              //.attr("dx", function(d) { return (d.x + rotate) % 360 < 180 ? 8 : -8; })
              //.attr("text-anchor", function(d) { return (d.x + rotate) % 360 < 180 ? "start" : "end"; })
              //.attr("transform", function(d) { return (d.x + rotate) % 360 < 180 ? null : "rotate(180)"; });
              .style('font-weight', nodeBold);
              //.attr("transform", function(d) {"translate(" + rx + "+5, " + ry + "+5)"});
              //.attr("transform", "translate(240,240)")
              //.attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
              //.attr("dy", ".31em")
              //.attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
              //.attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
              //.attr("transform", function(d) { return "translate(" + (d.x - 2) + "," + (d.y - 2) + ")"; });
              //.attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")"; });
              //.attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + pop*value) + ")"; });
              //.attr("dx", d.dx+pop)
              //.attr("transform", function(d) {"translate(" + 100 + "," + 100 + ")"});
              //.style("-webkit-transform", "translateY(" + (ry - rx) + "px)");
              //.attr("dx", function(d) {"30em"})*/
        };
      }

      function removelinks(){
        for(var i = 0; i < clickedData.length-1; i++){
          clickedData[i].clicked = false

          svg.selectAll("path.link.target-" + clickedData[i].key)
            .classed('target', false)
            .style("stroke-opacity", 0.05)
            .each(updateNodes("source", false));

          svg.selectAll("path.link.source-" + clickedData[i].key)
            .classed('source', false)
            .style("stroke-opacity", 0.05)
            .each(updateNodes("target", false,));

          /*textVal = svg.select("#node-" + clickedData[i].key + " text")

          if(textVal.attr("dx") > 8){
            textVal.attr("dx", 8)
          }
          else if(textVal.attr("dx") < 8){
            textVal.attr("dx", -8)
          }*/

          /*svg.select("#node-" + clickedData[i].key + " text")
              .filter(function(){
                return d3.select(this).attr("dx") > 8
              })
              .attr("dx", 8)

          svg.selectAll(".node text")
              .filter(function(){
                return d3.select(this).attr("dx") < -8 && !d.clicked
              })
              .attr("dx", -pop*val - pop)*/
        }
      }

      function drawConnections(){
        still = true;
        nConn = clickedData.length
        if(nConn === 0){
          still = false
          return;
        }
        else if(nConn === 1){
          svg.selectAll("path.link")
              .classed("source", false)
              .style("stroke-opacity", 0.01)

          svg.selectAll(".node text").style('opacity', 0.5)

          svg.selectAll(".node circle").style('opacity', 0.5)

          sourceName = clickedData[0].key

          svg.selectAll("path.link.source-" + sourceName)
              .classed("source", true)
              .style("stroke-opacity", 1)

          svg.selectAll(".node")
              .filter(function(){
                return d3.select(this).select(" text").attr("dx") != 8 &&
                        d3.select(this).select(" text").attr("dx") != -8 &&
                        d3.select(this).attr("class") !== "node";
              })
              .selectAll(" text")
              .style('opacity', 1)
              .style("font-weight", "bold")

          svg.selectAll(".node")
              .filter(function(){
                return d3.select(this).select(" text").attr("dx") != 8 &&
                        d3.select(this).select(" text").attr("dx") != -8 &&
                        d3.select(this).attr("class") !== "node";
              })
              .selectAll(" circle")
              .style("opacity", 1)

        }
        else{
          svg.selectAll("path.link")
              .classed("source", false)
              .style("stroke-opacity", 0.01)

          svg.selectAll(".node text")
              .style("font-weight", "normal")
              .style('opacity', 0.5)

          svg.selectAll(".node circle").style('opacity', 0.5)

          svg.selectAll(".node")
              .filter(function(){
                return d3.select(this).select(" text").attr("dx") < -8;
              })
              .selectAll(" text")
              .attr("dx", -8)

          svg.selectAll(".node")
              .filter(function(){
                return d3.select(this).select(" text").attr("dx") > 8;
              })
              .selectAll(" text")
              .attr("dx", 8)

          for(i in clickedData){
            i = parseInt(i)
            if(i != nConn-1){
              sourceName = clickedData[i].key
              targetName = clickedData[i+1].key
              svg.select("path.link.source-" + sourceName + ".target-" + targetName)
                  .classed("source", true)
                  .style("stroke-opacity", 1)
            }
            svg.select("#node-" + clickedData[i].key + " text")
                .attr("dx", function(d){
                  if(d3.select("#node-" + clickedData[i].key + " text").attr("dx") == -8){
                    return -16;
                  }
                  else{
                    return 16;
                  }
                })
                .style('font-weight', 'bold')
                .style('opacity', 1);

            svg.select("#node-" + clickedData[i].key + " circle")
                .style("opacity", 1)


            /*svg.selectAll(".node")

                .selectAll(" text")
                .attr("dx", 8)

            svg.selectAll(".node")
                .filter(function(){
                  return d3.select(this).select(" text").attr("dx") < -8 && d3.select(this).attr("class") === "node";
                })
                .selectAll(" text")
                .attr("dx", -8)*/
          }
        }
      }

      function cross(a, b) {
        return a[0] * b[1] - a[1] * b[0];
      }

      function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }

      function paintWindow(d, option){
        if(option === 1){
          windowFields = ['Gene Name: ',
                          d.key,
                          'Interactions: ' + d.datasource.length,
                          'Confidence: ' + d.Confidence]
          windowFields = [].concat.apply([], windowFields);
          var textColor = d.color
          windowText.data(windowFields)
            .enter()
              .append("svg:text")
              .attr("class", "vizText")
              .style("fill", function(d, i){
                if(i===1){
                  return textColor;
                }
              })
              .attr("font-family", "Helvetica")
              .attr("transform", function(d) { return "translate(0,20)"; })
              .attr("dy", function(d, i){
                return i*20;
              })
              .attr("dx", function(d, i){
                if(i===1){
                  return 10;
                }
                else{
                  return 2;
                }
              })
              .text(function(d){return d;});
        }
        else if(option === 2){
          n = clickedData[clickedData.length-1]
          //geneFamily = fixStrings(n.parent.name)
          windowFields = ['Gene Name: ',
                          n.key,
                          'Interactions: ' + n.datasource.length,
                          'Confidence: ' + n.Confidence]
          windowFields = [].concat.apply([], windowFields);
          var textColor = n.color;
          var windowL = windowFields.length;
          windowText.data(windowFields)
            .enter()
              .append("svg:text")
              .attr("class", "vizText")
              .style("fill", function(d, i){
                if(i===1){
                  return textColor;
                }
              })
              .attr("transform", function(d) { return "translate(0,20)"; })
              .attr("dy", function(d, i){
                return i*20;
              })
              .attr("dx", function(d, i){
                if(i===1){
                  return 10;
                }
                else{
                  return 2;
                }
              })
              .attr("font-family", "Helvetica")
              .text(function(d){return d;});
        }
        else{
          n = clickedData[clickedData.length-1]
          cInd = childrenArray.indexOf(d.name)
          windowFields = ['Linked Gene: ', d.key,
                          'Reference Gene: ', n.key,
                          'Interactions: ' + d.weights.length,
                          'Score: ' + n.weights[cInd],
                          'Source: ' + n.datasource[cInd]];
          var linkedColor = d.color;
          var refColor = n.color;
          windowText.data(windowFields)
            .enter()
              .append("svg:text")
              .attr("class", "vizText")
              .style("fill", function(d, i){
                if(i === 1){
                  return linkedColor;
                }
                else if(i === 3){
                  return refColor;
                }
              })
              .attr("transform", function(d) { return "translate(0,20)"; })
              .attr("dy", function(d, i){
                return i*20;
              })
              .attr("dx", function(d, i){
                return (i>3 || i % 2 ===0) ? 2 : 10;
              })
              .attr("font-family", "Helvetica")
              .text(function(d){return d;});
        }
      }

      /*function fixStrings(s, cut=18){
        if(s.length <= cut){
          return s;
        }
        else{
          var strings = []
          words = s.split(' ')
          vals = Math.floor(s.length/cut)
          b = 0;
          for(j=0; j<=vals; j++){
            a = b;
            for(i=a; i<=words.length; i++){
              test = words.slice(a, i+1).join(' ')
              if(test.length >= cut){
                b = i+1;
                break;
              }
            }
            if(j != vals){
              strings.push(words.slice(a, b).join(' '))
            }
            else{
              strings.push(words.slice(b).join(' '))
            }
          }
          return(strings)
        }
      }*/
    </script>
  </body>
</html>
